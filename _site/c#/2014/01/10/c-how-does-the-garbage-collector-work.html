<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>[C#] How does the garbage collector work? &#8211; </title>
<meta name="description" content="">
<meta name="keywords" content="c#, clr">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="[C#] How does the garbage collector work?">
<meta property="og:description" content="">
<meta property="og:url" content="/c%23/2014/01/10/c-how-does-the-garbage-collector-work.html">
<meta property="og:site_name" content="">
<meta property="og:image" content="/images/">





<link rel="canonical" href="/c%23/2014/01/10/c-how-does-the-garbage-collector-work.html">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="stylesheet" type="text/css" href="/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css" />






<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">

</head>
<body class="post-template" itemscope itemtype="http://schema.org/WebPage">  

<header id="masthead" class="blog-background overlay align-center align-middle animated from-bottom"  style="background-image: url(/images/)" itemscope itemtype="http://schema.org/Organization">


    <div class="inner">
        <div class="container">
            <a class="brand" href="/" role="banner" itemprop="url">

                

            <h1 class="blog-title light" itemprop="name">
                
            </h1>
                
            </a>
        </div>
    </div>
    
    
    <div class="decor-wrapper">
        <svg id="header-decor" class="decor bottom" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
            <path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path>

            <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path>

        </svg>
    </div>
    
</header>
<div id="main" class="content" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
    <div class="container">
        <div class="row">
            <article class="post col-md-8 col-md-offset-2 hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
            
            
            
                
            
             
             
                    <header class="post-header entry-header">
                        
                        <h1 class="post-title text-center hyper lighter bordered-bottom entry-title" itemprop="headline">[C#] How does the garbage collector work?</h1>
                        
                        <div class="post-info text-center small">
                            <span class="entry-date date published updated"><time datetime="2014-01-10T00:00:00+01:00" class="post-time" itemprop="datePublished">10 Jan 2014</time><span>
                            in <span class="post-tags"><a href="/categories/index.html#c#" data-toggle="tooltip" title="Other posts from the C# category" rel="tag">C#</a></span>
                        </div>
                    </header>
                    <div class="post-body bordered-bottom" itemprop="description">
                        
                        <h2 id="what_is_garbage">What is garbage?</h2>

<p>“Garbage” consists of objects created during a program’s execution on the managed heap that are no longer accessible by the program. Their memory can be reclaimed and reused with no averse effects.</p>

<h2 id="what_is_the_garbage_collector">What is the garbage collector?</h2>

<p>The garbage collector is a mechanism which identifies garbage on the managed heap and makes its memory available for reuse. This eliminates the need for the programmer to manually delete objects which are no longer required for program execution. This reuse of memory helps reduce the amount of total memory that a program needs to run. In technical terms, we say that it keeps the program’s “working set” small.</p>

<h2 id="how_does_the_garbage_collector_identify_garbage">How does the garbage collector identify garbage?</h2>

<p>In Microsoft’s implementation of the .NET framework the garbage collector determines if an object is garbage by examining the reference type variables pointing to it. In the context of the garbage collector, reference type variables are known as “roots”. Examples of roots include:</p>
<ul>
<li>A reference on the stack</li>
<li>A reference in a static variable</li>
<li>A reference in another object on the managed heap that is not eligible for garbage collection</li>
<li>A reference in the form of a local variable in a method</li>
</ul>
<p>Take the following method.</p>
<div class='highlight'><pre><code class='csharp'><span class='k'>void</span> <span class='nf'>CreateList</span><span class='p'>()</span>
<span class='p'>{</span>
	<span class='kt'>var</span> <span class='n'>myList</span> <span class='p'>=</span> <span class='k'>new</span> <span class='n'>List</span><span class='p'>&lt;</span><span class='kt'>object</span><span class='p'>&gt;();</span>
	<span class='n'>myList</span><span class='p'>.</span><span class='n'>Add</span><span class='p'>(</span><span class='k'>new</span> <span class='kt'>object</span><span class='p'>());</span>
	<span class='n'>myList</span><span class='p'>.</span><span class='n'>Add</span><span class='p'>(</span><span class='k'>new</span> <span class='kt'>object</span><span class='p'>());</span>
	<span class='n'>myList</span><span class='p'>.</span><span class='n'>Add</span><span class='p'>(</span><span class='k'>new</span> <span class='kt'>object</span><span class='p'>());</span>
	<span class='n'>Console</span><span class='p'>.</span><span class='n'>WriteLine</span><span class='p'>(</span><span class='s'>&quot;Objects added!&quot;</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre></div>
<p>When the method starts to execute, a <code>List&lt;object&gt;</code> is instantiated on the managed heap along with several objects. The List contains a root to each of the objects, and the stack contains a root to the List. While the method is executing, all of these roots are accessible from within the program and are considered to be “active”. When the method finishes executing, the stack is cleaned up, removing the root pointing to the List. The List is now no longer accessible within the program. All of the roots contained by the List (those pointing to the objects) are now considered to be “inactive”.</p>

<p>The garbage collector identifies garbage by examining an application’s roots. Objects which have no active roots pointing to them are considered to be garbage. <a id='more' /><a id='more-3232' /></p>

<h2 id="how_does_the_garbage_collector_manage_to_collect_garbage_without_impacting_application_performance">How does the garbage collector manage to collect garbage without impacting application performance?</h2>

<p>The truth is that the garbage collector <em>does</em> impact application performance. However, Microsoft has done a very good job at ensuring that it runs as quickly and efficiently as possible, and its impact is virtually unnoticeable from a user standpoint. It manages to do this by employing a wide variety of strategies and optimisations, a few of which we’ll talk about here.</p>

<h3 id="reference_tracking_optimisations">Reference tracking optimisations</h3>

<p>When the garbage collector begins a collection, it starts by setting a bit on every object which <em>could potentially</em> be garbage to 0. This marks these objects for collection. It then traverses the active roots in the application and sets that bit to 1 on every object which is not in fact garbage.</p>

<p>Remember from our previous example that when an object is considered not to be garbage, all objects that it references are also considered not to be garbage. This means that marking a single object as not garbage (such as a List) can result in hundreds or thousands of others also being marked. The garbage collector makes this process more efficient by examining the garbage collection bit before marking a given object. If the bit is already set to 1, it simply moves on, knowing that the object and its roots and their roots and so on and so forth have already been traversed. This makes the marking process significantly more efficient.</p>

<h3 id="generations">Generations</h3>

<p>The garbage collector makes one big assumption about the lifetime of objects in an application.</p>

<blockquote>
<p>The length of time that an object has been alive is inversely proportional to the probability that it will need to be garbage collected.</p>
</blockquote>

<p>Put another way, objects that have been around for a long time are fairly unlikely to be garbage, and objects that haven’t been around for so long are considerably more likely to be garbage. By and large, this assumption proves to be true for most applications. The garbage collector leverages this fact to improve performance by implementing what are known as generations.</p>

<p>You can think of generations as a way of classifying objects by how long they have been alive. The garbage collector groups objects into three generations, known as generations 0, 1 and 2. Objects in generation 0 have never survived a garbage collection. They’re brand new! Objects in generation 1 have survived one garbage collection, and objects in generation 2 have survived two or more collections.</p>

<p>When a garbage collection begins, the garbage collector can pick and choose which generations it wishes to collect. On average, collections in generation 0 will be more effective than those in generation 1, and those in generation 1 will be more effective than those in generation 2. The garbage collector can therefore decide to only collect generation 0, for example, and hopefully reclaim a substantial amount of memory without having to collect the entire managed heap.</p>

<h3 id="compacting">Compacting</h3>

<p>When the runtime allocates heap memory, it attempts to do so in a linear fashion. Objects are created one after another on the heap, and the runtime makes use of what is called the “next object pointer” to know where to place the next object. As you can imagine, however, once a garbage collection has taken place, the once smooth, contiguous block of memory that made up the heap is left full of holes. However, the garbage collector doesn’t leave the heap in this state*. Instead, it embarks on a compacting phase, whereby it moves objects back towards the beginning of the heap, filling the reclaimed memory spaces in the process.</p>

<p>As you can imagine, moving objects around is no trivial matter. When an object is moved in memory, existing references to it need to be updated. This understandably requires that program execution be suspended, as to ensure that all references to a given object are valid at all times during program execution. The CLR attempts to make this suspension as painless as possible by fine-tuning how and when garbage collection executes. Details of these techniques go beyond the scope of this article, but can be found <a href="http://msdn.microsoft.com/en-us/library/ee851764(v=vs.110">here on the MSDN website</a>.aspx).</p>

<h3 id="smart_invocation">Smart invocation</h3>

<p>The garbage collector ensures that it only collects garbage when it really needs to by setting out a memory budget for each of its three generations. These budgets can be modified by the CLR throughout program execution in order to be as well-adapted as possible to the execution conditions of a given program. When generation 0 of the managed heap surpasses its budget, the garbage collection process begins. The garbage collector checks to see if any other generations have surpassed their budgets, and then decides which generations to actually collect. This often means that garbage collection is only performed on a portion of the objects living on the managed heap, which makes the process significantly more efficient.</p>

<p>It is important to note that while the majority of garbage collections in an average program are invoked when generation 0 exceeds its memory budget, garbage collections can also be triggered by other events. These include the system reporting low memory conditions, the unloading of an AppDomain, the shutting down of the CLR, or a manual call to the GC.Collect method**.</p>

<h2 id="final_word">Final word</h2>

<p>Hopefully this article will have given you a broad idea of how the garbage collector works in Microsoft’s implementation of the .NET Framework. The garbage collector is a very, very complex mechanism which could merit its own book, and this article by no means constitutes a deep dive into its inner workings. Instead, I’ve attempted to provide a simple and concise explanation of the key talking points, with hopes that it will give you a basic understanding of what goes on behind the scenes in your .NET programs.</p>
<hr />
<p>* Actually, it does leave the large object heap in this state. The large object heap is beyond the scope of this article, however so you won’t hear any more about it for the time being.</p>

<p>** Calling GC.Collect is discouraged by Microsoft and is generally to be avoided. The garbage collector is a very intelligent mechanism, and has much more information at its disposal than you do when it evaluates whether or not a collection is needed.</p>
                        <br>
                    <span class="entry-tags">
                    <p>
                        <i class="icon-tags"></i>&nbsp;Tagged with <a href="/tags/index.html#c#" data-toggle="tooltip" title="Posts tagged with c#" rel="tag">c#</a>&nbsp;&bull;&nbsp;<a href="/tags/index.html#clr" data-toggle="tooltip" title="Posts tagged with clr" rel="tag">clr</a>
                    </p>
                    </span>
                    </div>
        </div>
                    <footer class="post-footer entry-meta">
                        
                        <div class="post-author text-center">                       
	        <img src="/images/" alt="'s photo" itemprop="image" class="post-avatar img-circle img-responsive"/>    
	    <h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="http://schema.org/Person">By <span itemprop="name" class="fn"><a href="/about" title="About " itemprop="url"></a></span></h4>
	    <p></p>
</div> 
                        
                    </footer>
            </article>
    </div>
</div>

<footer id="footer"  class="blog-background overlay text-center align-middle animated from-top" style="background-image: url(/images/)" >


    <div class="inner">
        <div class="container">

            <ul class="social-icons">
            
            
            
            
            
            
            
            
            
        </ul>
            <p class="copy-text">
                <a href="/about/"></a> &copy; 2014 &bull; All rights reserved.
            </p>
            <p class="copy-text">
                Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <i class="icon-heart"></i> <a href="http://alum.mit.edu/www/hmfaysal/">HMFAYSAL OMEGA</a> theme.
            </p>
            <ul class="menu-items">
            
            <li><a href="/feed.xml" title="Atom/RSS feed"><i class="icon-rss"></i> Feed</a></li>
            
        </ul>
        </div>
    </div>
    
        <div class="decor-wrapper">
            <svg id="footer-decor" class="decor top" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none">
                <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path>

                <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path>

            </svg>
        </div>
    
</footer>

    
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>
    
    <script type="text/javascript" src="/assets/js/script.js"></script>



<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> 
</body>
</html>